# Project 02 - Battleship

Names: Israel Pina, Esteak Shapin, Logan Ruzzier<br>
Period: 4

**Project Description:** We are aiming to create a socket-based two-player game, specifically a recreation of Battleship. After the first player creates a single-use (non-forking) server he waits for a second player to connect to him, at which point there will be a continuous sharing of information between the two linked systems through a socket. Congruous with the original Battleship, each player will have two boards to look at to help strategize their offensive and defensive game. Before the game begins, each player will place their ships on the board one at a time, indicating the coordinates of their intended position. The players will then take turns inputting a pair of coordinates to “fire,” and these coordinates will be sent to the other player, at which point it is determined whether this shot was a hit or a miss. Both players will be immediately notified of the shot’s outcome, and the result will be indicated on each player’s pair of boards. The “firer” will see every square he has previously fired at, and whether this shot was a hit, on one of his boards (in this case the board devoid of ships). The “firee” will see every square that his opponent has fired at, and whether this shot was a hit, on one of his boards (in this case the board with the ships on it). After this, accordingly, the players will switch roles. This cycle will repeat until one of the players has all of their ships “sunk” (this occurs when every square previously delineated to be part of a ship has been hit by the opponent), and their opponent wins. Following the end of the game, both players will be prompted for a rematch, and should they both agree, they both return to the ship placement screen for another round of Battleship. </br>

**User Interface:** The user interface will be the raw terminal (at least initially, if we make good time on the rest of the project we’ll attempt a graphical interface using the SDL libraries). Once the project file is run, the user will be asked whether he wishes to “Create a game” or “Join a game,” which will decide whether the program follows the server- or client-side protocols for starting up. It will wait for a connection before starting the game. Before any game-related communication takes place, the players must decide on the placement of their ships on the board, which will be completed one at a time. The program will prompt the player for the placement of one of the ships (i.e. “Please enter the desired coordinates of your submarine (3 spaces), followed by the desired orientation in the following format: “(X, N) Vertical/Horizontal”) before indicating on the player’s personal board the spaces this ship occupies. It must be checked before the ship is placed whether it does not fit on the board or overlaps another ship. Following the ship placement phase, the players will take turns sending coordinates to fire at (i.e. “Please enter the desired coordinates of your torpedo strike in the following format: “(X, N)”) and then receive the outcome of this shot. The hits/misses of your shots and the opponents will be indicated by varying symbols/colors on the squares of your graph-like board. Once one of the players wins by successfully hitting all of the opponents’ ships squares, they will receive a congratulatory message, followed by a prompt of whether they want a rematch (i.e. “Do you want to play again? “Y/N”). The opponent will receive a similar message, and should they both answer “Y,” the game will restart and they’ll pick spots for their ships once again.

**Technical Design:** Seeing as this project will be a two-player, network-based game, it will rely on the use of sockets, similarly to how they were used in Work 23 (minus the forking server aspect). It will also need to allocate memory to store the contents of the players' boards (2 each), and rely on 2-D array semantics to determine ship placements, hits, and displaying the board. For taking player inputs the program will need to handle files and stdin. It will likely also rely on some other concepts, such as signal handling, to provide the user with a more refined experience (you need to know when your opponent abandons the game!). Depending on how ambitious we become in the later stages of the project, we may also utilize structs for socket communication in place of integers or strings, and perhaps utilize them for player-to-player communication. However, the biggest portion of this project will deal with the order of messages being read and written with the socket. Seeing as our game will need many inputs being sent and received in a very specific schedule, the majority of our attention will likely be spent orchestrating this. Israel and Logan will focus on the socket-based communication and organization aspects of the project, whereas Shapin will accomplish the graphical points.

**Required Libraries:**<br>
-SDL

**How to install SDL:**<br>
If you have Ubunto, running "sudo apt-get install libsdl2-2.0" should work.<br>
For installing through the Windows command line (MinGW), [this website provides a helpful tutorial in doing so.](https://lazyfoo.net/tutorials/SDL/01_hello_SDL/windows/mingw/index.php).<br>
For macOS users, [use this tutorial.](https://www.kth.se/social/files/56fd013ff276544e9cfdccd9/SDL-Setup-Mac%2810.11.1%29-Xcode%287.0.1%29.pdf)

**Timeline:**<br>
Jan 12-13: Shapin familiarizes with SDL; Logan and Israel will plan the game’s algorithms and build the initial server-client interaction, mimicking a two-member chat server, and start coding the game.<br>
Jan 14-15: Shapin codes the graphics for the game; Logan and Israel will continue coding the game and make it work through the terminal without graphics for now.<br>
Jan 16-18: We all work together to synthesize the graphics and the actual game’s code together.<br>
Jan 19-20: Find a way to implement a chat server that runs along with the game to allow for player communication. Any leftover bugs will also be checked for and fixed.
